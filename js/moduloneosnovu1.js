// -----------------------------------------------РОЗГАЛУЖЕННЯ---------------------------------------------------

// -----------------------------------------------Інструкція if-------------------------------------------------

// Принцип роботи простий - результат умови приводиться до буля true або false, після чого потік програми спрямовується в ту або іншу гілку.

// Вхідні дані, які приводяться до буля, називаються умовою. Умова ставиться після оператора if в круглих дужках. Якщо умова приводиться до true, то виконується код у фігурних дужках тіла if.

// let cost = 0;
// const subscription = "pro";

// if (subscription === "pro") {
//   cost = 100;
// }

// console.log(cost); // 100

// Якщо умова приводиться до false код у квадратних дужках буде пропущено

// let cost = 1;
// const subscription = "free";

// if (subscription === "pro") {
//   cost = 100;
// }

// console.log(cost); // 0

// --------------------------------------------Інструкція if...else--------------------------------------------------

// Розширює синтаксис if таким чином, що якщо умова приводиться до false, виконається код у фігурних дужках після оператора else.
// Конструкція if...else може перевірити і зреагувати на виконання або невиконання лише однієї умови.

// let cost;
// const subscription = "free";

// if (subscription === "pro") {
//   cost = 100;
// } else {
//   cost = 0;
// }

// console.log(cost); // 0

// Якщо умова приводиться до true, тіло блока else ігнорується.

// let cost;
// const subscription = "pro";

// if (subscription === "pro") {
//   cost = 100;
// } else {
//   cost = 0;
// }

// console.log(cost); // 100

// -------------------------------------------Інструкція else...if--------------------------------------

// Блок else...if дозволяє додати після else ще один оператор if з умовою. В кінці ланцюжка може бути класичний блок else, який виконається лише у тому випадку, якщо жодна умова не приведеться до true.

// let cost;
// const subscription = "premium";

// if (subscription === "free") {
//   cost = 0;
// } else if (subscription === "pro") {
//   cost = 100;
// } else if (subscription === "premium") {
//   cost = 500;
// } else {
//   console.log("Invalid subscription type");
// }

// console.log(cost); // 500

// ---------------------------------------------ТЕРНАРНИЙ ОПЕРАТОР----------------------------------------------------------

// Тернарний оператор використовується у якості синтаксично коротшої заміни інструкції if...else, коли одній і тій самій змінній необхідно присвоїти різні значення за умовою.

//* <умова> ? <вираз_якщо_умова_правдива> : <вираз_якщо_умова_хибна></вираз_якщо_умова_хибна> */

// const age = 20;
// const type = age >= 18 ? "adult" : "child";
// console.log(type); // "adult"

// ще один приклад пошук більшого числа 

// використовуючи if...else рішення виглядає дуже громістким

// const num1 = 5;
// const num2 = 10;
// let biggerNumber;

// if (num1 > num2) {
//   biggerNumber = num1;
// } else {
//   biggerNumber = num2;
// }

// console.log(biggerNumber); // 10

// переробимо його на тернанрий оператор

// const num1 = 5;
// const num2 = 10;
// const biggerNumber = num1 > num2 ? num1 : num2;

// console.log(biggerNumber); // 10

// ------------------------------------------------Інструкція switch-----------------------------------------------------

// Межі застосування switch обмежені задачами з одним загальним запитанням (що порівнювати) і рядом варіантів відповідей (з чим порівнювати).
// Для порівняння використовується оператор строгої рівності ===. Тобто, не можна порівняти більше або менше, лише рівність.
// switch(значення) - рядок або число, яке порівнюється щодо строгої рівності з усіма значеннями в блоках case значення по черзі, зверху вниз.
// Оператор break в кінці кожного блоку case необхідний, щоб перервати подальші перевірки і одразу перейти до коду за switch у тому випадку, коли перевірка рівності повернула true.
// Якщо жодного збігу значень не відбулося, необхідно виконати код за замовчуванням. Для цього, після усіх блоків case додається блок default. Оператор break після блоку default не потрібен, тому що це вже остання операція, яка буде виконана в switch і управління буде передано коду після нього.

// let cost;
// const subscription = "premium";

// switch (subscription) {
//   case "free":
//     cost = 0;
//     break;

//   case "pro":
//     cost = 100;
//     break;

//   case "premium":
//     cost = 500;
//     break;

//   default:
//     console.log("Invalid subscription type");
// }

// console.log(cost); // 500

// -------------------------------------------------ОБЛАСТЬ ВИДИМОСТІ------------------------------------------------------

// Глобальна область видимості використовується за замовчуванням. Кожен має доступ до змінних, оголошених в ній. Наприклад, змінна value оголошена у глобальній області видимості, тобто поза будь-яким блоком, і доступна в будь-якому місці після оголошення.

// const value = 5;

// if (true) {
//   console.log("Block scope: ", value); // 5
// }

// console.log("Global scope: ", value); // 5

// Будь-яка конструкція, яка використовує фігурні дужки {} (умови, цикли, функції тощо), створює нову локальну область видимості, і змінні, оголошені в цій області видимості, з використанням let або const, - недоступні за межами цього блоку.

// if (true) {
//     const value = 5;
//     console.log("Block scope: ", value); // 5
//   }
  
//   console.log("Global scope: ", value); // ReferenceError: value is not defined

// Глибина вкладеності областей видимості - необмежена, і всі вони будуть працювати за одним принципом - область видимості має доступ до всіх змінних, оголошених вище по ієрархії вкладеності, але не може отримати доступ до змінних, оголошених у вкладених областях видимості.

// const global = "global";

// if (true) {
//   const blockA = "block A";

//   // Бачимо глобальну + локальну A
//   console.log(global); // 'global'
//   console.log(blockA); // block A

//   // Змінні blockB і blockC не знайдені в доступних областях видимості.
//   // Буде помилка звернення до змінної.
//   console.log(blockB); // ReferenceError: blockB is not defined
//   console.log(blockC); // ReferenceError: blockC is not defined

//   if (true) {
//     const blockB = "block B";

//     // Бачимо глобальну + зовнішню A + локальну B
//     console.log(global); // global
//     console.log(blockA); // block A
//     console.log(blockB); // block B

//     // Змінна blockC не знайдена в доступних областях видимості.
//     // Буде помилка звернення до змінної.
//     console.log(blockC); // ReferenceError: blockC is not defined
//   }
// }

// if (true) {
//   const blockC = "block C";

//   // Бачимо глобальну + локальну C
//   console.log(global); // global
//   console.log(blockC); // block C

//   // Змінні blockA і blockB не знайдені в доступних областях видимості.
//   // Буде помилка звернення до змінної.
//   console.log(blockA); // ReferenceError: blockA is not defined
//   console.log(blockB); // ReferenceError: blockB is not defined
// }

// // Бачимо лише глобальну
// console.log(global); // global

// // Змінні blockA, blockB і blockC не знайдені в доступних областях видимості.
// // Буде помилка звернення до змінної.
// console.log(blockA); // ReferenceError: blockA is not defined
// console.log(blockB); // ReferenceError: blockB is not defined
// console.log(blockC); // ReferenceError: blockC is not defined

// -------------------------------------------ЦИКЛИ---------------------------------------------------------

// Цикл - керуюча конструкція у високорівневих мовах програмування, призначена для організації багаторазового виконання набору інструкцій.
// Тіло циклу - послідовність інструкцій, призначена для багаторазового виконання.
// Ітерація - одноразове виконання тіла циклу.
// Умова виходу - вираз, що визначає, чи буде в черговий раз виконуватися ітерація, або цикл завершиться.
// Лічильник - змінна, що зберігає поточний номер ітерації. Цикл не обов'язково містить лічильник, і він не повинен бути один, умова виходу з циклу може залежати від декількох змінних, що змінюються в циклі.

// ------------------------------------------------Цикл while--------------------------------------------------------

//цикл, який виконується, доки правдива якась умова, зазначена до його початку. Ця умова перевіряється до виконання тіла циклу, тому тіло може не виконатися жодного разу, якщо умова від самого початку - хибна.

// Конструкція while створює цикл, який виконує блок коду, доки умова перевірки оцінюється як true.

// let counter = 0;

// while (counter < 10) {
//   console.log("counter: ", counter);
//   counter += 1;
// }

// let counter = 0;

// while (counter < 8) {
//     console.log("counter: ", counter);
//     counter += 1
// }

// let counter = 0

// while (counter < 5) {
//     console.log("counter: ", counter)
//     counter += 1
// }

// let counter = 0; 
// while (counter < 7) {
//     console.log("counter: ", counter)
//     counter += 1
// }

// let counter = 0

// while (counter < 3) {
//     console.log("counter: ", counter)
//     counter += 1
// }

// Будемо заповнювати місця в готелі доти, доки поточна кількість клієнтів не буде дорівнювати максимально можливій.

// let clientCounter = 7;
// const maxClients = 25;

// while (clientCounter < maxClients) {
//   console.log(clientCounter);
//   clientCounter += 1;
// }


// let appleCounter = 21
// const otherAppleCounter = 30

// while (appleCounter < otherAppleCounter) {
//     console.log(appleCounter);
//     appleCounter += 1;
// }

// let mathCounter = 1
// const otherCounter = 20

// while (mathCounter < otherCounter) {
//     console.log(mathCounter)
//     mathCounter += 1
// }

// let prod = 5
// const countProd = 10

// while (prod < countProd) {
//     console.log(prod)
//     prod += 1
// }


// --------------------------------------------------Цикл do...while--------------------------------------------------------

// Цикл з постумовою - цикл, в якому умова перевіряється після виконання тіла циклу. З цього випливає, що тіло завжди виконується хоча б один раз.

// let password = "";

// do {
//   password = prompt("Введіть пароль довший 4-х символів", "");
// } while (password.length < 5);

// console.log("Ввели пароль: ", password);


// let password = "";

// do {
//     password = prompt ("введіть пароль довший за 3-х символи", "");
// } while (password.length < 4);

// console.log("ввели пароль:", password);

// let password = "";

// do {
//     password = prompt('введіть пароль з більше ніж 5-х символів', password)
// } while (password.length < 6);

// console.log("введіть пароль", password)

// let password = "";

// do {
//     password = prompt ('введіть пароль бульше ніж 5 символів', password)
// } while (password.length < 6);

// console.log('введіть пароль', password)

// ---------------------------------------------------Цикл for----------------------------------------------------------

// цикл, в якому певна змінна змінює своє значення із заданого початкового до кінцевого значення з деяким кроком, і для кожного значення цієї змінної тіло циклу виконується один раз.
// В більшості процедурних мов програмування реалізується конструкцією for, в якій зазначається лічильник, необхідна кількість ітерацій і крок, з яким змінюється лічильник.

// for (initialization; condition; post-expression) {
//     // statements
//   }

// Алгоритм виконання циклу for:

// - Ініціалізація (initialization) - виконується один раз до початку циклу. Використовується для створення змінної-лічильника і зазначення її початкового значення.
// - Умова (condition) - вираз, що оцінюється перед кожною ітерацією (повторенням) циклу. Тіло циклу виконується тільки тоді, коли вираз приводиться до true. Цикл завершується, якщо значення буде false.
// - Тіло (statements) - набір інструкцій для виконання на кожному повторенні. Виконується, якщо вираз умови приводиться до true.
// - Пост-вираз (post-expression) - виконується в кінці кожного повторення циклу, до перевірки умови. Використовується для оновлення змінної-лічильника.
// - Змінні-лічильники, за традицією, називаються літерами i, j і k

// for (let i = 0; i <= 20; i += 5) {
//     console.log(i);
//   }

// for (let i = 0; i <= 20; i += 2) {
//     console.log(i);
// }

// for (let i = 0; i < 10; i += 1) {
//     console.log(i)
// }

// for (let i = 0; i <= 15; i += 5) {
//     console.log(i)
// }

// У прикладі оголошується змінна-лічильник i, ініціалізується значенням 0 і цикл виконується доти, доки i <= 20, тобто умова приводиться до true. Після кожної ітерації лічильник збільшується на 5.

// Порахуємо суму чисел до певного значення.

// const target = 8;
// let sum = 0;

// for (let i = 0; i < target; i += 1) {
//   sum += i;
// }

// console.log(sum); 


// додає 1+2+3+4+5+6+7 = 28

// const target = 5
// let sum = 0

// for (let i = 0; i < target; i += 1) {
//     sum += i;
// }

// console.log(sum)

// const target = 3
// let multiply = 2

// for (let i = 1; i < target; i += 1) {
//     multiply *= i;
// }

// console.log(multiply)

// Згадаємо про операцію a % b і виведемо остачу від ділення за допомогою циклу.

// const max = 10;
// for (let i = 1; i < max; i += 1) {
//   console.log(`${max} % ${i} = `, max % i);
// }

// в результаті в нас виконається

    // 10 % 1 =  0
    // 10 % 2 =  0
    // 10 % 3 =  1
    // 10 % 4 =  2
    // 10 % 5 =  0
    // 10 % 8 =  2
    // 10 % 6 =  4
    // 10 % 7 =  3
    // 10 % 9 =  1

// ----------------------------------------------------оператор break---------------------------------------------------------------

// Перервати виконання циклу можна в будь-який момент. Для цього існує оператор break, який повністю припиняє виконання циклу і передає управління на рядок після його тіла.
// Знайдемо число 3. Щойно виконається умова if, цикл припинить своє виконання (буде перерваний).

// for (let i = 0; i <= 5; i += 1) {
//     console.log(i);
  
//     if (i === 3) {
//       console.log("Знайшли число 3, перериваємо виконання циклу");
//       break;
//     }
//   }
  
//   console.log("Лог після циклу");

// -------------------------------------------оператор continue------------------------------------------------------

// Перериває не увесь цикл, а тільки виконання поточної ітерації. Його використовують, якщо зрозуміло, що на поточній ітерації циклу більше немає що робити або взагалі не потрібно нічого робити, і час переходити до наступної ітерації.

// Використовуємо цикл для введення тільки непарних чисел. Для парних i спрацьовує continue, виконання тіла припиняється і управління передається до наступної ітерації.

// const number = 10;

// for (let i = 0; i < number; i += 1) {
//   if (i % 2 === 0) {
//     continue;
//   }

//   console.log("Непарне i: ", i); // 1, 3, 5, 7, 9
// }


// ----------------------------------------------------закріпдення--------------------------------------------------------------------

// const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// for (let i = 0; i < numbers.length; i += 1) {
//     console.log(numbers[i])
// }

// let i = 0;
// while (i < numbers.length) {
//     console.log(numbers[i]);
//     i += 1;
// }



// let i = 0;
// do {
//     console.log(numbers[i]);
//     i += 1;
// } while (i < numbers.length)

// const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// for (let i = 0; i < numbers.length; i += 1) {
//     if (i % 2 !== 0) {
//         continue; // можна порівняти з пропуском ходу в настільній грі.
//         // break // можна порівняти з повним завершенням настільної гри
//     }
//     console.log(numbers[i])
// }


// const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// for (let i = 0; i < numbers.length; i += 1) {
//    if (numbers[i] === 3) {
//     break
//    }
//     console.log(numbers[i])
// }
