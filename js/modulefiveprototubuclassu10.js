// -------------------------------------------------------ПРОТОТИПИ КЛАСИ------------------------------------------------------

// ---------------------------------------------Об'єктно-орієнтоване програмування---------------------------------------------

// Процедурне програмування - набір не пов'язаних явно функцій і змінних для зберігання і обробки інформації. Цей підхід - простий і прямолінійний, і може використовуватись для задач, в яких немає тісно пов'язаних сутностей (даних і функцій для їх обробки).

// Розглянемо приклад процедурного коду, в якому є змінні і функція для підрахунку результату.

// const baseSalary = 30000;
// const overtime = 10;
// const rate = 20;

// const getWage = (baseSalary, overtime, rate) => {
//   return baseSalary + overtime * rate;
// };

// getWage(baseSalary, overtime, rate);


// Об'єктно-орієнтоване програмування (ООП) - методологія, яка описує програму як сукупність об'єктів, кожен з яких містить дані (властивості) і методи для взаємодії з ними.

// Використовуємо ООП, зібравши дані в об'єкт employee.

// const employee = {
//     baseSalary: 30000,
//     overtime: 10,
//     rate: 20,
//     getWage() {
//       return this.baseSalary + this.overtime * this.rate;
//     },
//   };
  
//   console.log(employee.getWage());
  

// const user = {
//     bestScore: 10000,
//     playtime: 10,
//     rate: 10,
//     getStats() {
//         return this.bestScore + this.playtime * this.rate
//     }
// }

// console.log(user.getStats())

// const totalSales = {
//     bestSales: 15000,
//     worTime: 8,
//     rate: 5,


//     getSales() {
//         return this.bestSales + this.worTime * this.rate
//     }
// }

// console.log(totalSales.getSales())

// За такого підходу у методі відсутні параметри, використовуються властивості об'єкта, які задаються на момент створення об'єкта і можуть так само змінюватися іншими методами. На виході отримуємо сутність з простим інтерфейсом, що зменшує складність програми

// ----------------------------------------------------Сутності ООП--------------------------------------------------------------------------

// Уявіть собі, що ми проектуємо автомобіль. У нього буде двигун, чотири колеса, бензобак тощо. Автомобіль повинен мати можливість заводитися, збільшувати і зменшувати швидкість. Ми знаємо як взаємодіє двигун і колеса, тобто за якими законами взаємодіють різні частини машини.

// ------------------------------------------------------Клас------------------------------------------------------------------------------

// Клас - спосіб опису сутності, що визначає стан і поведінку, яка залежить від цього стану, а також правила для взаємодії з цією сутністю (контракт).

// У нашому випадку, клас визначає сутність - автомобіль. Властивостями класу будуть двигун, колеса, фари тощо. Методами класу будуть дії: відкрити двері, завести двигун, збільшити швидкість тощо.

// ----------------------------------------------------------Екземпляр------------------------------------------------------------------------

// Ми спроектували креслення, та автомобілі, розроблені на підставі них, сходять з конвеєру. Кожен з них точно повторює креслення, усі системи взаємодіють саме так, як ми спроектували, але кожний автомобіль - унікальний. Вони всі мають номер кузова і двигуна, але всі номери різні, автомобілі розрізняються за кольором, оздобленням салону. Ці автомобілі - це екземпляри класу.

// Екземпляр (об'єкт) - це окремий представник класу, який має конкретний стан і поведінку, що повністю визначається класом. Це те, що створено за кресленням, тобто на підставі опису з класу.

// Простіше кажучи, об'єкт має конкретні значення властивостей і методи, що працюють з цими властивостями на основі правил, заданих в класі. У цьому прикладі, якщо клас - це якийсь абстрактний автомобіль на кресленні, то об'єкт - це конкретний автомобіль, що стоїть у нас під вікнами.

// --------------------------------------------------------Інтерфейс-------------------------------------------------------------------------

// Коли ми підходимо до автомата з кавою або сідаємо за кермо автомобіля, існує певний набір елементів управління, з якими ми можемо взаємодіяти.

// Інтерфейс - це набір властивостей і методів класу, доступних для використання у роботі з екземпляром.

// По суті, інтерфейс описує клас, чітко визначаючи усі можливі дії над ним. Хороший приклад інтерфейсу - панель приладів автомобіля, яка дозволяє викликати методи як-от збільшення швидкості, гальмування, повертання, перемикання передач, увімкнення фар тощо.

// Описуючи інтерфейс класу, дуже важливо витримати баланс між гнучкістю і простотою. Клас з простим інтерфейсом буде легко використовувати, але будуть існувати завдання, які, за допомогою нього, буде складно вирішити.

// Якщо інтерфейс буде гнучким, то, найімовірніше, він буде містити досить складні методи з великою кількістю параметрів, які будуть дозволяти робити дуже багато, але його використання буде пов'язане з великими труднощами і ризиком помилитися, переплутавши щось.


// ---------------------------------------------------ПРОТОТИПНЕ НАСЛІДУВАННЯ----------------------------------------------------------------

// ООП в JavaScript побудовано на прототипному наслідуванні. Об'єкти можна організувати у ланцюжки таким чином, щоб здійснювався автоматичний пошук властивості в іншому об'єкті, не знайденої в одному об'єкті. Сполучною ланкою виступає спеціальна прихована властивість [[Prototype]], яка в консолі браузера відображається як __proto__.

// -------------------------------------------------------Прототип об'єкта-----------------------------------------------------------------

// Метод Object.create(obj) створює і повертає новий об'єкт, зв'язуючи його з об'єктом obj.

// const animal = {
//     legs: 4,
//   };
//   const dog = Object.create(animal);
//   dog.name = "Манго";
  
//   console.log(dog); // { name: 'Манго', __proto__: animal }
//   console.log(animal.isPrototypeOf(dog)); // true

// Об'єкт, на який вказує посилання в __proto__, називається прототипом. У нашому прикладі об'єкт animal - це прототип для об'єкта dog. Метод isPrototypeOf() перевіряє, чи є об'єкт animal прототипом для dog і чи повертає true або false.

// console.log(dog.hasOwnProperty("name")); // true
// console.log(dog.name); // 'Манго'

// console.log(dog.hasOwnProperty("legs")); // false
// console.log(dog.legs); // 4

// Звернення dog.name працює очевидним чином - повертає власну властивість name об'єкта dog. Звертаючись до dog.legs, інтерпретатор шукає властивість legs в об'єкті dog, не знаходить і продовжує пошук в об'єкті за посиланням з dog.__ proto__, тобто, у цьому випадку, в об'єкті animal - його прототипі.

// Тобто прототип - це резервне сховище властивостей і методів об'єкта, автоматично використовується під час їх пошуку. Об'єкт, який виступає прототипом, може також мати свій прототип, наступний - свій, і так далі.

// Пошук властивості виконується до першого збігу. Інтерпретатор шукає властивість за ім'ям в об'єкті, якщо не знаходить, то звертається до властивості __proto__, тобто переходить за посиланням до об'єкта-прототипу, а потім - до прототипу прототипу. Якщо інтерпретатор дійде до кінця ланцюжка і не знайде властивості з таким ім'ям, то поверне undefined

// ------------------------------------------------------Метод hasOwnProperty()-------------------------------------------------------------


// Після того як ми дізналися про спосіб пошуку властивостей об'єкта, повинно бути зрозуміло, чому цикл for...in не розрізняє властивості об'єкта і його прототипу.

// const animal = { eats: true };
// const dog = Object.create(animal);
// dog.barks = true;

// for (const key in dog) {
//   console.log(key); // barks, eats
// }

// Саме тому ми використовуємо метод obj.hasOwnProperty(prop), який повертає true, якщо властивість prop належить об'єкту obj, а не його прототипу, інакше - false.

// const animal = {
//     eats: true,
//   };
//   const dog = Object.create(animal);
//   dog.barks = true;
  
//   for (const key in dog) {
//     if (!dog.hasOwnProperty(key)) continue;
  
//     console.log(key); // barks
//   }

// Метод Object.keys(obj) поверне масив тільки власних ключів об'єкта obj, тому, на практиці використовують саме його, а не for...in.

// const animal = {
//     eats: true,
//   };
//   const dog = Object.create(animal);
//   dog.barks = true;
  
//   const dogKeys = Object.keys(dog);
  
//   console.log(dogKeys); // ['barks']

// const тварина = {
//     їсть: true,
// };

// const собака = Object.create(тварина);
// собака.гавкає = true;

// const собакаКлюч = Object.keys(собака);
// console.log(собакаКлюч);

// ---------------------------------------------------------КЛАСИ-----------------------------------------------------------------------------

// Синтаксис літерала об'єкта дозволяє створити один об'єкт. Проте, часто потрібно створити багато однотипних об'єктів з однаковим набором властивостей, але різними значеннями і методами для взаємодії з ними. Все це потрібно робити динамічно, під час виконання програми. З цією метою використовують класи - спеціальний синтаксис оголошення функції для створення об'єктів.

// -----------------------------------------------------Оголошення класу---------------------------------------------------------------------

// Оголошення класу починається з ключового слова class, після якого стоїть ім'я класу і фігурні дужки - його тіло. Класи прийнято називати з великої літери, а у назві відображати тип об'єкта (іменника), що створюється.

// class User {
//     // Тіло класу
//   }
  
//   const mango = new User();
//   console.log(mango); // {}
  
//   const poly = new User();
//   console.log(poly); // {}

// Результат виклику new User() - це об'єкт, який називається екземпляром класу, тому що містить дані і поведінку, що описуються класом.

// Метод побудови класу залежить від того, що вам потрібно. У нашому випадку, клас - це користувач, тому ми додамо в нього поля для імені та пошти.

// ----------------------------------------------------Конструктор класу------------------------------------------------------------------

// Для ініціалізації екземпляра в класі є метод constructor. Якщо він неоголошений, створюється конструктор за замовчуванням - порожня функція, яка не змінює екземпляр.

// class User {
//     // Синтаксис оголошення методу класу
//     constructor(name, email) {
//       // Ініціалізація властивостей екземпляра
//       this.name = name;
//       this.email = email;
//     }
//   }
  
//   const mango = new User("Манго", "mango@mail.com");
//   console.log(mango); // { name: 'Манго', email: 'mango@mail.com' }
  
//   const poly = new User("Поли", "poly@mail.com");
//   console.log(poly); // { name: 'Поли', email: 'poly@mail.com' }

// -----------------------практика

// class Admin {
//     constructor(name, email) {
//         this.name = name;
//         this.email = email;
//     }
// }

// const ropan = new Admin("Ropan", "ropan@mail.com");
// console.log(ropan);

// const ruban = new Admin("Ruban", "ruban@mail.com")
// console.log(ruban);

// class Team {
//     constructor (email, name) {
//         this.name = name;
//         this.email = email;
//     }
// }

// const teamcool = new Team ( "teamwork@mail.com", "Team Work")
// console.log(teamcool)

// const teamcyber = new Team ("cyber@mail.com", "Cyber")
// console.log(teamcyber)

// class Car {
//     constructor(name, model) {
//         this.name = name;
//         this.model = model;
//     }
// }

// const mers = new Car ("mercedes", "sl500")
// console.log(mers)

// const bmw = new Car ("BMW", "XX")
// console.log(bmw)

// class Juice {
//     constructor (name, price) {
//         this.name = name;
//         this.price = price;
//     }
// }

// const orange = new Juice ("Sandora", "70₴")
// console.log(orange)

// const cherry = new Juice ("Садочок", "77₴")
// console.log(cherry)

// class Icecream {
//     constructor (name, color) {
//         this.name = name;
//         this.color = color;
//     }
// }

// const chocolate = new Icecream ("Chocodream", "Black")
// console.log(chocolate)

// const milky = new Icecream ("Milkyway", "White")
// console.log(milky)

// class Cinema {
//     constructor (genre, year) {
//         this.genre = genre;
//         this.year = year;
//     }
// }

// const history = new Cinema ("Historical", "2007")
// console.log(history)

// const animal = new Cinema ("Lion", "2012")
// console.log(animal)

// Виклик класу з оператором new призводить до створення нового об'єкта і виклику конструктора в контексті цього об'єкта. Тобто this всередині конструктора буде посилатися на новостворений об'єкт. Це дозволяє додавати кожному об'єкту властивості з однаковими іменами, але різними значеннями.

// Властивості name та email називаються публічними властивостями, тому що вони будуть власними властивостями об'єкта-екземпляра і до них можна буде отримати доступ, звернувшись через крапку.